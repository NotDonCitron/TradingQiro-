#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VIP-GRUPPEN PROBLEM DIAGNOSE & L√ñSUNG
Umfassendes Script zur Behebung des VIP-Gruppen-Zugriffsproblems
"""

import asyncio
import os
import sys
from datetime import datetime
from typing import Dict, Any, List, Optional
from telethon import TelegramClient
from telethon.errors import ChannelPrivateError, ChatAdminRequiredError, PeerIdInvalidError
from telethon.tl.types import Channel, Chat, User

class VIPGroupDiagnoser:
    """Diagnostiziert und l√∂st VIP-Gruppen-Zugriffsprobleme"""
    
    def __init__(self):
        # API Credentials (hardcodiert f√ºr Diagnose)
        self.api_id = 26708757
        self.api_hash = "e58c6204a1478da2b764d5fceff846e5"
        self.bot_token = "8496816723:AAHH-YVZdmoueA_cV9lcJncUyIR3N3Vizbw"
        
        # Session verwenden
        self.session_name = "user_telegram_session"
        self.client = TelegramClient(self.session_name, self.api_id, self.api_hash)
        
        # Zielgruppen
        self.vip_group_id = -2299206473  # VIP Signal Group (Problem)
        self.cryptet_channel_id = -1001804143400  # Cryptet Official Channel
        self.target_group_id = -1002773853382  # PH FUTURES VIP (Ziel)
        
        # Diagnose-Ergebnisse
        self.diagnosis_results = {
            "session_status": False,
            "vip_access": False,
            "membership_status": False,
            "permission_level": None,
            "error_details": [],
            "recommendations": []
        }
    
    async def send_report_message(self, message: str) -> bool:
        """Sende Diagnosebericht an Zielgruppe"""
        try:
            import requests
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            data = {
                "chat_id": str(self.target_group_id),
                "text": message,
                "parse_mode": "Markdown"
            }
            response = requests.post(url, json=data, timeout=10)
            return response.status_code == 200
        except Exception as e:
            print(f"‚ùå Report Send Error: {e}")
            return False
    
    async def test_session_status(self) -> bool:
        """Teste Session-Status"""
        try:
            await self.client.start()
            me = await self.client.get_me()
            
            self.diagnosis_results["session_status"] = True
            
            print(f"‚úÖ Session erfolgreich:")
            print(f"   Name: {me.first_name} {me.last_name or ''}")
            print(f"   Username: @{me.username or 'kein_username'}")
            print(f"   ID: {me.id}")
            print(f"   Telefon: {me.phone or 'nicht verf√ºgbar'}")
            print(f"   Bot: {getattr(me, 'bot', False)}")
            
            return True
            
        except Exception as e:
            self.diagnosis_results["error_details"].append(f"Session Error: {e}")
            print(f"‚ùå Session Fehler: {e}")
            return False
    
    async def test_vip_group_access(self) -> Optional[Any]:
        """Teste VIP-Gruppen-Zugriff mit verschiedenen Methoden"""
        print("\nüîç VIP-GRUPPEN ZUGRIFF DIAGNOSE")
        print("=" * 50)
        
        methods = [
            ("Direkt get_entity", self._try_direct_entity),
            ("Via get_dialogs", self._try_via_dialogs),
            ("Via iter_dialogs", self._try_via_iter_dialogs),
            ("Mit PeerChannel", self._try_peer_channel)
        ]
        
        for method_name, method_func in methods:
            print(f"\nüì° {method_name}...")
            try:
                result = await method_func()
                if result:
                    print(f"‚úÖ {method_name} erfolgreich!")
                    self.diagnosis_results["vip_access"] = True
                    return result
                else:
                    print(f"‚ùå {method_name} fehlgeschlagen")
            except Exception as e:
                error_msg = f"{method_name} Error: {str(e)}"
                print(f"‚ùå {error_msg}")
                self.diagnosis_results["error_details"].append(error_msg)
        
        return None
    
    async def _try_direct_entity(self) -> Optional[Any]:
        """Versuch 1: Direkter Entity-Zugriff"""
        try:
            entity = await self.client.get_entity(self.vip_group_id)
            print(f"   Typ: {type(entity).__name__}")
            print(f"   Titel: {getattr(entity, 'title', 'Unknown')}")
            print(f"   ID: {entity.id}")
            return entity
        except Exception:
            return None
    
    async def _try_via_dialogs(self) -> Optional[Any]:
        """Versuch 2: √úber get_dialogs"""
        try:
            dialogs = await self.client.get_dialogs()
            for dialog in dialogs:
                if dialog.id == self.vip_group_id:
                    print(f"   Gefunden in Dialogs: {dialog.title}")
                    return dialog.entity
            return None
        except Exception:
            return None
    
    async def _try_via_iter_dialogs(self) -> Optional[Any]:
        """Versuch 3: √úber iter_dialogs"""
        try:
            async for dialog in self.client.iter_dialogs():
                if dialog.id == self.vip_group_id:
                    print(f"   Gefunden via iter_dialogs: {dialog.title}")
                    return dialog.entity
            return None
        except Exception:
            return None
    
    async def _try_peer_channel(self) -> Optional[Any]:
        """Versuch 4: Mit PeerChannel"""
        try:
            from telethon.tl.types import PeerChannel
            # VIP-Gruppe hat negative ID, konvertiere zu Channel-ID
            channel_id = abs(self.vip_group_id) - 1000000000000
            peer = PeerChannel(channel_id)
            entity = await self.client.get_entity(peer)
            print(f"   PeerChannel erfolgreich: {getattr(entity, 'title', 'Unknown')}")
            return entity
        except Exception:
            return None
    
    async def check_membership_status(self, entity: Any) -> Dict[str, Any]:
        """Pr√ºfe Mitgliedschaft und Berechtigungen"""
        try:
            print("\nüë• MITGLIEDSCHAFT & BERECHTIGUNGEN")
            print("=" * 40)
            
            # Versuche Teilnehmer zu bekommen
            try:
                participants = await self.client.get_participants(entity, limit=1)
                print(f"‚úÖ Kann Teilnehmer abrufen: {len(participants)} Teilnehmer verf√ºgbar")
                
                # Pr√ºfe eigene Mitgliedschaft
                me = await self.client.get_me()
                my_participant = None
                
                try:
                    my_participant = await self.client.get_participants(entity, search=me.username or str(me.id), limit=1)
                    if my_participant:
                        print(f"‚úÖ Mitgliedschaft best√§tigt")
                        self.diagnosis_results["membership_status"] = True
                    else:
                        print(f"‚ùå Keine Mitgliedschaft gefunden")
                        self.diagnosis_results["recommendations"].append("Account muss zur VIP-Gruppe hinzugef√ºgt werden")
                except Exception as e:
                    print(f"‚ö†Ô∏è Mitgliedschaftspr√ºfung fehlgeschlagen: {e}")
                
            except Exception as e:
                print(f"‚ùå Kann keine Teilnehmer abrufen: {e}")
                self.diagnosis_results["recommendations"].append("Keine Berechtigung zum Lesen der Teilnehmerliste")
            
            # Versuche Nachrichten zu lesen
            try:
                messages = []
                async for message in self.client.iter_messages(entity, limit=3):
                    if message.text:
                        messages.append({
                            "id": message.id,
                            "text": message.text[:100] + "..." if len(message.text) > 100 else message.text,
                            "date": message.date.strftime("%Y-%m-%d %H:%M:%S") if message.date else "Unknown"
                        })
                
                if messages:
                    print(f"‚úÖ Kann Nachrichten lesen: {len(messages)} aktuelle Nachrichten")
                    self.diagnosis_results["permission_level"] = "read_messages"
                    return {"can_read": True, "messages": messages}
                else:
                    print(f"‚ö†Ô∏è Keine Nachrichten verf√ºgbar")
                    return {"can_read": False, "messages": []}
                    
            except Exception as e:
                print(f"‚ùå Kann keine Nachrichten lesen: {e}")
                self.diagnosis_results["error_details"].append(f"Read Messages Error: {e}")
                self.diagnosis_results["recommendations"].append("Keine Berechtigung zum Lesen von Nachrichten")
                return {"can_read": False, "error": str(e)}
                
        except Exception as e:
            print(f"‚ùå Membership Check Error: {e}")
            self.diagnosis_results["error_details"].append(f"Membership Check Error: {e}")
            return {"error": str(e)}
    
    async def test_environment_config(self) -> Dict[str, Any]:
        """Teste Umgebungskonfiguration"""
        print("\n‚öôÔ∏è UMGEBUNGSKONFIGURATION")
        print("=" * 30)
        
        config_status = {
            "api_credentials": False,
            "bot_token": False,
            "monitored_chats": False,
            "session_file": False
        }
        
        # API Credentials
        api_id = os.getenv("TELEGRAM_API_ID")
        api_hash = os.getenv("TELEGRAM_API_HASH")
        if api_id and api_hash:
            print(f"‚úÖ API Credentials konfiguriert")
            config_status["api_credentials"] = True
        else:
            print(f"‚ö†Ô∏è API Credentials fehlen in Umgebungsvariablen")
        
        # Bot Token
        bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
        if bot_token:
            print(f"‚úÖ Bot Token konfiguriert")
            config_status["bot_token"] = True
        else:
            print(f"‚ö†Ô∏è Bot Token fehlt")
        
        # Monitored Chats
        monitored_chats = os.getenv("MONITORED_CHAT_IDS", "")
        if monitored_chats:
            chat_list = [int(x.strip()) for x in monitored_chats.split(",") if x.strip()]
            print(f"‚úÖ √úberwachte Chats: {chat_list}")
            
            if self.vip_group_id in chat_list:
                print(f"‚úÖ VIP-Gruppe ({self.vip_group_id}) ist √ºberwacht")
                config_status["monitored_chats"] = True
            else:
                print(f"‚ùå VIP-Gruppe ({self.vip_group_id}) NICHT in √ºberwachten Chats!")
                self.diagnosis_results["recommendations"].append(f"VIP-Gruppe {self.vip_group_id} zu MONITORED_CHAT_IDS hinzuf√ºgen")
        else:
            print(f"‚ö†Ô∏è Keine √ºberwachten Chats konfiguriert")
        
        # Session File
        session_file = f"{self.session_name}.session"
        if os.path.exists(session_file):
            print(f"‚úÖ Session-Datei vorhanden: {session_file}")
            config_status["session_file"] = True
        else:
            print(f"‚ùå Session-Datei fehlt: {session_file}")
            self.diagnosis_results["recommendations"].append("Session-Datei erstellen oder wiederherstellen")
        
        return config_status
    
    async def generate_diagnosis_report(self) -> str:
        """Generiere umfassenden Diagnosebericht"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Status-Emojis
        session_emoji = "‚úÖ" if self.diagnosis_results["session_status"] else "‚ùå"
        vip_emoji = "‚úÖ" if self.diagnosis_results["vip_access"] else "‚ùå"
        membership_emoji = "‚úÖ" if self.diagnosis_results["membership_status"] else "‚ùå"
        
        report = f"""üîç **VIP-GRUPPEN DIAGNOSE BERICHT** üîç

üïê **Zeitstempel:** {timestamp}
üéØ **Ziel:** VIP-Gruppe ({self.vip_group_id}) Zugriffsproblem l√∂sen

üìä **DIAGNOSE-ERGEBNISSE:**

{session_emoji} **Session-Status:** {'Funktional' if self.diagnosis_results['session_status'] else 'Fehlerhaft'}
{vip_emoji} **VIP-Zugriff:** {'Erfolgreich' if self.diagnosis_results['vip_access'] else 'Fehlgeschlagen'}  
{membership_emoji} **Mitgliedschaft:** {'Best√§tigt' if self.diagnosis_results['membership_status'] else 'Nicht best√§tigt'}
üîê **Berechtigungen:** {self.diagnosis_results['permission_level'] or 'Keine'}

‚ö†Ô∏è **FEHLER-DETAILS:**"""

        if self.diagnosis_results["error_details"]:
            for i, error in enumerate(self.diagnosis_results["error_details"], 1):
                report += f"\n{i}. {error}"
        else:
            report += "\nKeine kritischen Fehler gefunden."

        report += "\n\nüí° **EMPFEHLUNGEN:**"
        
        if self.diagnosis_results["recommendations"]:
            for i, rec in enumerate(self.diagnosis_results["recommendations"], 1):
                report += f"\n{i}. {rec}"
        else:
            report += "\nKeine weiteren Ma√ünahmen erforderlich."

        # N√§chste Schritte
        if not self.diagnosis_results["vip_access"]:
            report += "\n\nüîß **N√ÑCHSTE SCHRITTE:**"
            report += "\n1. Account zur VIP-Gruppe hinzuf√ºgen"
            report += "\n2. MONITORED_CHAT_IDS konfigurieren"
            report += "\n3. System neu starten"
            report += "\n4. Diagnose wiederholen"

        return report
    
    async def run_full_diagnosis(self) -> None:
        """F√ºhre vollst√§ndige Diagnose durch"""
        print("üöÄ VIP-GRUPPEN PROBLEM DIAGNOSE STARTET")
        print("=" * 60)
        
        try:
            # Startmeldung senden
            start_msg = f"""üîç **VIP-GRUPPEN DIAGNOSE GESTARTET** üîç

üïê **Zeit:** {datetime.now().strftime('%H:%M:%S')}
üéØ **Ziel:** VIP-Gruppe ({self.vip_group_id}) Problem l√∂sen

üîÑ **Status:** Diagnose l√§uft..."""
            
            await self.send_report_message(start_msg)
            
            # 1. Session-Test
            print("\n1Ô∏è‚É£ SESSION-STATUS TEST")
            session_ok = await self.test_session_status()
            
            if not session_ok:
                error_report = await self.generate_diagnosis_report()
                await self.send_report_message(error_report)
                return
            
            # 2. Umgebungskonfiguration
            print("\n2Ô∏è‚É£ UMGEBUNGSKONFIGURATION TEST")
            config_status = await self.test_environment_config()
            
            # 3. VIP-Gruppen-Zugriff
            print("\n3Ô∏è‚É£ VIP-GRUPPEN-ZUGRIFF TEST")
            vip_entity = await self.test_vip_group_access()
            
            # 4. Mitgliedschaftstest
            if vip_entity:
                print("\n4Ô∏è‚É£ MITGLIEDSCHAFTSTEST")
                membership_result = await self.check_membership_status(vip_entity)
            
            # 5. Abschlussbericht
            print("\n5Ô∏è‚É£ ABSCHLUSSBERICHT")
            final_report = await self.generate_diagnosis_report()
            print("\n" + final_report)
            
            await self.send_report_message(final_report)
            
            # 6. L√∂sungsvorschlag
            if self.diagnosis_results["vip_access"]:
                solution_msg = """üéâ **L√ñSUNG ERFOLGREICH!** üéâ

‚úÖ VIP-Gruppe ist nun zug√§nglich!
‚úÖ System sollte VIP-Signale empfangen k√∂nnen!

üöÄ **Empfehlung:** System neu starten um √Ñnderungen zu √ºbernehmen."""
                
                await self.send_report_message(solution_msg)
            else:
                solution_msg = """üîß **L√ñSUNGSSCHRITTE** üîß

‚ùó **Sofortige Ma√ünahmen:**
1. Account zur VIP-Gruppe hinzuf√ºgen
2. Bot-Berechtigungen in Gruppe √ºberpr√ºfen
3. MONITORED_CHAT_IDS konfigurieren
4. System-Neustart durchf√ºhren

üìû **Kontakt Admin:** Falls Problem weiterhin besteht"""
                
                await self.send_report_message(solution_msg)
                
        except Exception as e:
            error_msg = f"""‚ùå **DIAGNOSE FEHLER** ‚ùå

‚ö†Ô∏è **Error:** {str(e)}
üïê **Zeit:** {datetime.now().strftime('%H:%M:%S')}

üí° **Empfehlung:** Manuelle √úberpr√ºfung erforderlich"""
            
            print(f"‚ùå Diagnose Fehler: {e}")
            await self.send_report_message(error_msg)
            
        finally:
            await self.client.disconnect()
            print("‚úÖ Diagnose abgeschlossen")

async def main():
    """Hauptfunktion"""
    diagnoser = VIPGroupDiagnoser()
    await diagnoser.run_full_diagnosis()

if __name__ == "__main__":
    print("üéØ VIP-GRUPPEN PROBLEM DIAGNOSE & L√ñSUNG")
    print("Identifiziert und behebt VIP-Gruppen-Zugriffsprobleme")
    print()
    
    asyncio.run(main())